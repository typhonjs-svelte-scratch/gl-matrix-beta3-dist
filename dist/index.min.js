// gl-matrix - v4.0.0-beta.3 - A high performance matrix and vector library.
// @author Brandon Jones
// @author Colin MacKenzie IV
// @license MIT (https://github.com/toji/gl-matrix/blob/master/LICENSE.md)
import{GLM_EPSILON as W}from"gl-matrix/common";var G=class d extends Float32Array{static#t=new Float32Array([1,0,0,1]);constructor(...e){switch(e.length){case 4:super(e);break;case 2:super(e[0],e[1],4);break;case 1:let t=e[0];typeof t=="number"?super([t,t,t,t]):super(t,0,4);break;default:super(d.#t);break}}get str(){return d.str(this)}copy(e){return this.set(e),this}identity(){return this.set(d.#t),this}multiply(e){return d.multiply(this,this,e)}mul(e){return this}transpose(){return d.transpose(this,this)}invert(){return d.invert(this,this)}scale(e){return d.scale(this,this,e)}rotate(e){return d.rotate(this,this,e)}static get BYTE_LENGTH(){return 4*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static fromValues(...e){return new d(...e)}static set(e,...t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static identity(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e}static transpose(e,t){if(e===t){let n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e}static invert(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=n*r-i*s;return a?(a=1/a,e[0]=r*a,e[1]=-s*a,e[2]=-i*a,e[3]=n*a,e):null}static adjoint(e,t){let n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e}static determinant(e){return e[0]*e[3]-e[2]*e[1]}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e}static sub(e,t,n){return e}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[0],L=n[1],k=n[2],l=n[3];return e[0]=s*c+r*L,e[1]=i*c+a*L,e[2]=s*k+r*l,e[3]=i*k+a*l,e}static mul(e,t,n){return e}static rotate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=Math.sin(n),L=Math.cos(n);return e[0]=s*L+r*c,e[1]=i*L+a*c,e[2]=s*-c+r*L,e[3]=i*-c+a*L,e}static scale(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[0],L=n[1];return e[0]=s*c,e[1]=i*c,e[2]=r*L,e[3]=a*L,e}static fromRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=s,e[1]=n,e[2]=-n,e[3]=s,e}static fromScaling(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e}static frob(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3])}static multiplyScalar(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e}static multiplyScalarAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e[3]=t[3]+n[3]*s,e}static LDU(e,t,n,s){return e[2]=s[2]/s[0],n[0]=s[0],n[1]=s[1],n[3]=s[3]-e[2]*n[1],[e,t,n]}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=t[0],c=t[1],L=t[2],k=t[3];return Math.abs(n-a)<=W*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(s-c)<=W*Math.max(1,Math.abs(s),Math.abs(c))&&Math.abs(i-L)<=W*Math.max(1,Math.abs(i),Math.abs(L))&&Math.abs(r-k)<=W*Math.max(1,Math.abs(r),Math.abs(k))}static str(e){return`Mat2(${e.join(", ")})`}};G.prototype.mul=G.prototype.multiply;G.mul=G.multiply;G.sub=G.subtract;import{GLM_EPSILON as H}from"gl-matrix/common";var $=class d extends Float32Array{static#t=new Float32Array([1,0,0,1,0,0]);constructor(...e){switch(e.length){case 6:super(e);break;case 2:super(e[0],e[1],6);break;case 1:let t=e[0];typeof t=="number"?super([t,t,t,t,t,t]):super(t,0,6);break;default:super(d.#t);break}}get str(){return d.str(this)}copy(e){return this.set(e),this}identity(){return this.set(d.#t),this}multiply(e){return d.multiply(this,this,e)}mul(e){return this}translate(e){return d.translate(this,this,e)}rotate(e){return d.rotate(this,this,e)}scale(e){return d.scale(this,this,e)}static get BYTE_LENGTH(){return 6*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}static fromValues(...e){return new d(...e)}static set(e,...t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}static identity(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e}static invert(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=n*r-s*i;return L?(L=1/L,e[0]=r*L,e[1]=-s*L,e[2]=-i*L,e[3]=n*L,e[4]=(i*c-r*a)*L,e[5]=(s*a-n*c)*L,e):null}static determinant(e){return e[0]*e[3]-e[1]*e[2]}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e}static sub(e,t,n){return e}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=n[0],l=n[1],h=n[2],M=n[3],y=n[4],m=n[5];return e[0]=s*k+r*l,e[1]=i*k+a*l,e[2]=s*h+r*M,e[3]=i*h+a*M,e[4]=s*y+r*m+c,e[5]=i*y+a*m+L,e}static mul(e,t,n){return e}static translate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=n[0],l=n[1];return e[0]=s,e[1]=i,e[2]=r,e[3]=a,e[4]=s*k+r*l+c,e[5]=i*k+a*l+L,e}static rotate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=Math.sin(n),l=Math.cos(n);return e[0]=s*l+r*k,e[1]=i*l+a*k,e[2]=s*-k+r*l,e[3]=i*-k+a*l,e[4]=c,e[5]=L,e}static scale(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=n[0],l=n[1];return e[0]=s*k,e[1]=i*k,e[2]=r*l,e[3]=a*l,e[4]=c,e[5]=L,e}static fromTranslation(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=t[0],e[5]=t[1],e}static fromRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=s,e[1]=n,e[2]=-n,e[3]=s,e[4]=0,e[5]=0,e}static fromScaling(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e[4]=0,e[5]=0,e}static frob(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]+e[4]*e[4]+e[5]*e[5]+1)}static multiplyScalar(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e}static multiplyScalarAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e[3]=t[3]+n[3]*s,e[4]=t[4]+n[4]*s,e[5]=t[5]+n[5]*s,e}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=e[4],c=e[5],L=t[0],k=t[1],l=t[2],h=t[3],M=t[4],y=t[5];return Math.abs(n-L)<=H*Math.max(1,Math.abs(n),Math.abs(L))&&Math.abs(s-k)<=H*Math.max(1,Math.abs(s),Math.abs(k))&&Math.abs(i-l)<=H*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(r-h)<=H*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(a-M)<=H*Math.max(1,Math.abs(a),Math.abs(M))&&Math.abs(c-y)<=H*Math.max(1,Math.abs(c),Math.abs(y))}static str(e){return`Mat2d(${e.join(", ")})`}};$.mul=$.multiply;$.sub=$.subtract;import{GLM_EPSILON as j}from"gl-matrix/common";var Z=class d extends Float32Array{static#t=new Float32Array([1,0,0,0,1,0,0,0,1]);constructor(...e){switch(e.length){case 9:super(e);break;case 2:super(e[0],e[1],9);break;case 1:let t=e[0];typeof t=="number"?super([t,t,t,t,t,t,t,t,t]):super(t,0,9);break;default:super(d.#t);break}}get str(){return d.str(this)}copy(e){return this.set(e),this}identity(){return this.set(d.#t),this}multiply(e){return d.multiply(this,this,e)}mul(e){return this}transpose(){return d.transpose(this,this)}invert(){return d.invert(this,this)}translate(e){return d.translate(this,this,e)}rotate(e){return d.rotate(this,this,e)}scale(e){return d.scale(this,this,e)}static get BYTE_LENGTH(){return 9*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}static fromValues(...e){return new d(...e)}static set(e,...t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}static identity(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}static transpose(e,t){if(e===t){let n=t[1],s=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=s,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}static invert(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8],h=l*a-c*k,M=-l*r+c*L,y=k*r-a*L,m=n*h+s*M+i*y;return m?(m=1/m,e[0]=h*m,e[1]=(-l*s+i*k)*m,e[2]=(c*s-i*a)*m,e[3]=M*m,e[4]=(l*n-i*L)*m,e[5]=(-c*n+i*r)*m,e[6]=y*m,e[7]=(-k*n+s*L)*m,e[8]=(a*n-s*r)*m,e):null}static adjoint(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8];return e[0]=a*l-c*k,e[1]=i*k-s*l,e[2]=s*c-i*a,e[3]=c*L-r*l,e[4]=n*l-i*L,e[5]=i*r-n*c,e[6]=r*k-a*L,e[7]=s*L-n*k,e[8]=n*a-s*r,e}static determinant(e){let t=e[0],n=e[1],s=e[2],i=e[3],r=e[4],a=e[5],c=e[6],L=e[7],k=e[8];return t*(k*r-a*L)+n*(-k*i+a*c)+s*(L*i-r*c)}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}static sub(e,t,n){return e}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=t[8],M=n[0],y=n[1],m=n[2];return e[0]=M*s+y*a+m*k,e[1]=M*i+y*c+m*l,e[2]=M*r+y*L+m*h,M=n[3],y=n[4],m=n[5],e[3]=M*s+y*a+m*k,e[4]=M*i+y*c+m*l,e[5]=M*r+y*L+m*h,M=n[6],y=n[7],m=n[8],e[6]=M*s+y*a+m*k,e[7]=M*i+y*c+m*l,e[8]=M*r+y*L+m*h,e}static mul(e,t,n){return e}static translate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=t[8],M=n[0],y=n[1];return e[0]=s,e[1]=i,e[2]=r,e[3]=a,e[4]=c,e[5]=L,e[6]=M*s+y*a+k,e[7]=M*i+y*c+l,e[8]=M*r+y*L+h,e}static rotate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=t[8],M=Math.sin(n),y=Math.cos(n);return e[0]=y*s+M*a,e[1]=y*i+M*c,e[2]=y*r+M*L,e[3]=y*a-M*s,e[4]=y*c-M*i,e[5]=y*L-M*r,e[6]=k,e[7]=l,e[8]=h,e}static scale(e,t,n){let s=n[0],i=n[1];return e[0]=s*t[0],e[1]=s*t[1],e[2]=s*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}static fromTranslation(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}static fromRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=s,e[1]=n,e[2]=0,e[3]=-n,e[4]=s,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}static fromScaling(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}static fromMat2d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}static fromQuat(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=n+n,c=s+s,L=i+i,k=n*a,l=s*a,h=s*c,M=i*a,y=i*c,m=i*L,o=r*a,R=r*c,b=r*L;return e[0]=1-h-m,e[3]=l-b,e[6]=M+R,e[1]=l+b,e[4]=1-k-m,e[7]=y-o,e[2]=M-R,e[5]=y+o,e[8]=1-k-h,e}static fromMat4(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}static normalFromMat4(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8],h=t[9],M=t[10],y=t[11],m=t[12],o=t[13],R=t[14],b=t[15],f=n*c-s*a,V=n*L-i*a,p=n*k-r*a,Q=s*L-i*c,x=s*k-r*c,E=i*k-r*L,q=l*o-h*m,T=l*R-M*m,g=l*b-y*m,S=h*R-M*o,B=h*b-y*o,D=M*b-y*R,z=f*D-V*B+p*S+Q*g-x*T+E*q;return z?(z=1/z,e[0]=(c*D-L*B+k*S)*z,e[1]=(L*g-a*D-k*T)*z,e[2]=(a*B-c*g+k*q)*z,e[3]=(i*B-s*D-r*S)*z,e[4]=(n*D-i*g+r*T)*z,e[5]=(s*g-n*B-r*q)*z,e[6]=(o*E-R*x+b*Q)*z,e[7]=(R*p-m*E-b*V)*z,e[8]=(m*x-o*p+b*f)*z,e):null}static normalFromMat4Fast(e,t){let n=t[0],s=t[1],i=t[2],r=t[4],a=t[5],c=t[6],L=t[8],k=t[9],l=t[10];return e[0]=a*l-l*k,e[1]=c*L-L*l,e[2]=r*k-k*L,e[3]=k*i-l*s,e[4]=l*n-L*i,e[5]=L*s-k*n,e[6]=s*c-i*a,e[7]=i*r-n*c,e[8]=n*a-s*r,e}static projection(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}static frob(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]+e[4]*e[4]+e[5]*e[5]+e[6]*e[6]+e[7]*e[7]+e[8]*e[8])}static multiplyScalar(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}static multiplyScalarAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e[3]=t[3]+n[3]*s,e[4]=t[4]+n[4]*s,e[5]=t[5]+n[5]*s,e[6]=t[6]+n[6]*s,e[7]=t[7]+n[7]*s,e[8]=t[8]+n[8]*s,e}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=e[4],c=e[5],L=e[6],k=e[7],l=e[8],h=t[0],M=t[1],y=t[2],m=t[3],o=t[4],R=t[5],b=t[6],f=t[7],V=t[8];return Math.abs(n-h)<=j*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(s-M)<=j*Math.max(1,Math.abs(s),Math.abs(M))&&Math.abs(i-y)<=j*Math.max(1,Math.abs(i),Math.abs(y))&&Math.abs(r-m)<=j*Math.max(1,Math.abs(r),Math.abs(m))&&Math.abs(a-o)<=j*Math.max(1,Math.abs(a),Math.abs(o))&&Math.abs(c-R)<=j*Math.max(1,Math.abs(c),Math.abs(R))&&Math.abs(L-b)<=j*Math.max(1,Math.abs(L),Math.abs(b))&&Math.abs(k-f)<=j*Math.max(1,Math.abs(k),Math.abs(f))&&Math.abs(l-V)<=j*Math.max(1,Math.abs(l),Math.abs(V))}static str(e){return`Mat3(${e.join(", ")})`}};Z.prototype.mul=Z.prototype.multiply;Z.mul=Z.multiply;Z.sub=Z.subtract;import{GLM_EPSILON as I}from"gl-matrix/common";var Y=class d extends Float32Array{static#t=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);static#e=new Float32Array(3);constructor(...e){switch(e.length){case 16:super(e);break;case 2:super(e[0],e[1],16);break;case 1:let t=e[0];typeof t=="number"?super([t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t]):super(t,0,16);break;default:super(d.#t);break}}get str(){return d.str(this)}copy(e){return this.set(e),this}identity(){return this.set(d.#t),this}multiply(e){return d.multiply(this,this,e)}mul(e){return this}transpose(){return d.transpose(this,this)}invert(){return d.invert(this,this)}translate(e){return d.translate(this,this,e)}rotate(e,t){return d.rotate(this,this,e,t)}scale(e){return d.scale(this,this,e)}rotateX(e){return d.rotateX(this,this,e)}rotateY(e){return d.rotateY(this,this,e)}rotateZ(e){return d.rotateZ(this,this,e)}perspectiveNO(e,t,n,s){return d.perspectiveNO(this,e,t,n,s)}perspectiveZO(e,t,n,s){return d.perspectiveZO(this,e,t,n,s)}orthoNO(e,t,n,s,i,r){return d.orthoNO(this,e,t,n,s,i,r)}orthoZO(e,t,n,s,i,r){return d.orthoZO(this,e,t,n,s,i,r)}static get BYTE_LENGTH(){return 16*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}static fromValues(...e){return new d(...e)}static set(e,...t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}static identity(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static transpose(e,t){if(e===t){let n=t[1],s=t[2],i=t[3],r=t[6],a=t[7],c=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=s,e[9]=r,e[11]=t[14],e[12]=i,e[13]=a,e[14]=c}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}static invert(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8],h=t[9],M=t[10],y=t[11],m=t[12],o=t[13],R=t[14],b=t[15],f=n*c-s*a,V=n*L-i*a,p=n*k-r*a,Q=s*L-i*c,x=s*k-r*c,E=i*k-r*L,q=l*o-h*m,T=l*R-M*m,g=l*b-y*m,S=h*R-M*o,B=h*b-y*o,D=M*b-y*R,z=f*D-V*B+p*S+Q*g-x*T+E*q;return z?(z=1/z,e[0]=(c*D-L*B+k*S)*z,e[1]=(i*B-s*D-r*S)*z,e[2]=(o*E-R*x+b*Q)*z,e[3]=(M*x-h*E-y*Q)*z,e[4]=(L*g-a*D-k*T)*z,e[5]=(n*D-i*g+r*T)*z,e[6]=(R*p-m*E-b*V)*z,e[7]=(l*E-M*p+y*V)*z,e[8]=(a*B-c*g+k*q)*z,e[9]=(s*g-n*B-r*q)*z,e[10]=(m*x-o*p+b*f)*z,e[11]=(h*p-l*x-y*f)*z,e[12]=(c*T-a*S-L*q)*z,e[13]=(n*S-s*T+i*q)*z,e[14]=(o*V-m*Q-R*f)*z,e[15]=(l*Q-h*V+M*f)*z,e):null}static adjoint(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8],h=t[9],M=t[10],y=t[11],m=t[12],o=t[13],R=t[14],b=t[15],f=n*c-s*a,V=n*L-i*a,p=n*k-r*a,Q=s*L-i*c,x=s*k-r*c,E=i*k-r*L,q=l*o-h*m,T=l*R-M*m,g=l*b-y*m,S=h*R-M*o,B=h*b-y*o,D=M*b-y*R;return e[0]=c*D-L*B+k*S,e[1]=i*B-s*D-r*S,e[2]=o*E-R*x+b*Q,e[3]=M*x-h*E-y*Q,e[4]=L*g-a*D-k*T,e[5]=n*D-i*g+r*T,e[6]=R*p-m*E-b*V,e[7]=l*E-M*p+y*V,e[8]=a*B-c*g+k*q,e[9]=s*g-n*B-r*q,e[10]=m*x-o*p+b*f,e[11]=h*p-l*x-y*f,e[12]=c*T-a*S-L*q,e[13]=n*S-s*T+i*q,e[14]=o*V-m*Q-R*f,e[15]=l*Q-h*V+M*f,e}static determinant(e){let t=e[0],n=e[1],s=e[2],i=e[3],r=e[4],a=e[5],c=e[6],L=e[7],k=e[8],l=e[9],h=e[10],M=e[11],y=e[12],m=e[13],o=e[14],R=e[15],b=t*a-n*r,f=t*c-s*r,V=n*c-s*a,p=k*m-l*y,Q=k*o-h*y,x=l*o-h*m,E=t*x-n*Q+s*p,q=r*x-a*Q+c*p,T=k*V-l*f+h*b,g=y*V-m*f+o*b;return L*E-i*q+R*T-M*g}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=t[8],M=t[9],y=t[10],m=t[11],o=t[12],R=t[13],b=t[14],f=t[15],V=n[0],p=n[1],Q=n[2],x=n[3];return e[0]=V*s+p*c+Q*h+x*o,e[1]=V*i+p*L+Q*M+x*R,e[2]=V*r+p*k+Q*y+x*b,e[3]=V*a+p*l+Q*m+x*f,V=n[4],p=n[5],Q=n[6],x=n[7],e[4]=V*s+p*c+Q*h+x*o,e[5]=V*i+p*L+Q*M+x*R,e[6]=V*r+p*k+Q*y+x*b,e[7]=V*a+p*l+Q*m+x*f,V=n[8],p=n[9],Q=n[10],x=n[11],e[8]=V*s+p*c+Q*h+x*o,e[9]=V*i+p*L+Q*M+x*R,e[10]=V*r+p*k+Q*y+x*b,e[11]=V*a+p*l+Q*m+x*f,V=n[12],p=n[13],Q=n[14],x=n[15],e[12]=V*s+p*c+Q*h+x*o,e[13]=V*i+p*L+Q*M+x*R,e[14]=V*r+p*k+Q*y+x*b,e[15]=V*a+p*l+Q*m+x*f,e}static mul(e,t,n){return e}static translate(e,t,n){let s=n[0],i=n[1],r=n[2];if(t===e)e[12]=t[0]*s+t[4]*i+t[8]*r+t[12],e[13]=t[1]*s+t[5]*i+t[9]*r+t[13],e[14]=t[2]*s+t[6]*i+t[10]*r+t[14],e[15]=t[3]*s+t[7]*i+t[11]*r+t[15];else{let a=t[0],c=t[1],L=t[2],k=t[3],l=t[4],h=t[5],M=t[6],y=t[7],m=t[8],o=t[9],R=t[10],b=t[11];e[0]=a,e[1]=c,e[2]=L,e[3]=k,e[4]=l,e[5]=h,e[6]=M,e[7]=y,e[8]=m,e[9]=o,e[10]=R,e[11]=b,e[12]=a*s+l*i+m*r+t[12],e[13]=c*s+h*i+o*r+t[13],e[14]=L*s+M*i+R*r+t[14],e[15]=k*s+y*i+b*r+t[15]}return e}static scale(e,t,n){let s=n[0],i=n[1],r=n[2];return e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e[3]=t[3]*s,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}static rotate(e,t,n,s){let i=s[0],r=s[1],a=s[2],c=Math.sqrt(i*i+r*r+a*a);if(c<I)return null;c=1/c,i*=c,r*=c,a*=c;let L=Math.sin(n),k=Math.cos(n),l=1-k,h=t[0],M=t[1],y=t[2],m=t[3],o=t[4],R=t[5],b=t[6],f=t[7],V=t[8],p=t[9],Q=t[10],x=t[11],E=i*i*l+k,q=r*i*l+a*L,T=a*i*l-r*L,g=i*r*l-a*L,S=r*r*l+k,B=a*r*l+i*L,D=i*a*l+r*L,z=r*a*l-i*L,O=a*a*l+k;return e[0]=h*E+o*q+V*T,e[1]=M*E+R*q+p*T,e[2]=y*E+b*q+Q*T,e[3]=m*E+f*q+x*T,e[4]=h*g+o*S+V*B,e[5]=M*g+R*S+p*B,e[6]=y*g+b*S+Q*B,e[7]=m*g+f*S+x*B,e[8]=h*D+o*z+V*O,e[9]=M*D+R*z+p*O,e[10]=y*D+b*z+Q*O,e[11]=m*D+f*z+x*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e}static rotateX(e,t,n){let s=Math.sin(n),i=Math.cos(n),r=t[4],a=t[5],c=t[6],L=t[7],k=t[8],l=t[9],h=t[10],M=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=r*i+k*s,e[5]=a*i+l*s,e[6]=c*i+h*s,e[7]=L*i+M*s,e[8]=k*i-r*s,e[9]=l*i-a*s,e[10]=h*i-c*s,e[11]=M*i-L*s,e}static rotateY(e,t,n){let s=Math.sin(n),i=Math.cos(n),r=t[0],a=t[1],c=t[2],L=t[3],k=t[8],l=t[9],h=t[10],M=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=r*i-k*s,e[1]=a*i-l*s,e[2]=c*i-h*s,e[3]=L*i-M*s,e[8]=r*s+k*i,e[9]=a*s+l*i,e[10]=c*s+h*i,e[11]=L*s+M*i,e}static rotateZ(e,t,n){let s=Math.sin(n),i=Math.cos(n),r=t[0],a=t[1],c=t[2],L=t[3],k=t[4],l=t[5],h=t[6],M=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=r*i+k*s,e[1]=a*i+l*s,e[2]=c*i+h*s,e[3]=L*i+M*s,e[4]=k*i-r*s,e[5]=l*i-a*s,e[6]=h*i-c*s,e[7]=M*i-L*s,e}static fromTranslation(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}static fromScaling(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static fromRotation(e,t,n){let s=n[0],i=n[1],r=n[2],a=Math.sqrt(s*s+i*i+r*r);if(a<I)return null;a=1/a,s*=a,i*=a,r*=a;let c=Math.sin(t),L=Math.cos(t),k=1-L;return e[0]=s*s*k+L,e[1]=i*s*k+r*c,e[2]=r*s*k-i*c,e[3]=0,e[4]=s*i*k-r*c,e[5]=i*i*k+L,e[6]=r*i*k+s*c,e[7]=0,e[8]=s*r*k+i*c,e[9]=i*r*k-s*c,e[10]=r*r*k+L,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static fromXRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static fromYRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=s,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static fromZRotation(e,t){let n=Math.sin(t),s=Math.cos(t);return e[0]=s,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static fromRotationTranslation(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=s+s,L=i+i,k=r+r,l=s*c,h=s*L,M=s*k,y=i*L,m=i*k,o=r*k,R=a*c,b=a*L,f=a*k;return e[0]=1-(y+o),e[1]=h+f,e[2]=M-b,e[3]=0,e[4]=h-f,e[5]=1-(l+o),e[6]=m+R,e[7]=0,e[8]=M+b,e[9]=m-R,e[10]=1-(l+y),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}static fromQuat2(e,t){let n=-t[0],s=-t[1],i=-t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=n*n+s*s+i*i+r*r;return l>0?(d.#e[0]=(a*r+k*n+c*i-L*s)*2/l,d.#e[1]=(c*r+k*s+L*n-a*i)*2/l,d.#e[2]=(L*r+k*i+a*s-c*n)*2/l):(d.#e[0]=(a*r+k*n+c*i-L*s)*2,d.#e[1]=(c*r+k*s+L*n-a*i)*2,d.#e[2]=(L*r+k*i+a*s-c*n)*2),d.fromRotationTranslation(e,t,d.#e),e}static normalFromMat4(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=t[4],c=t[5],L=t[6],k=t[7],l=t[8],h=t[9],M=t[10],y=t[11],m=t[12],o=t[13],R=t[14],b=t[15],f=n*c-s*a,V=n*L-i*a,p=n*k-r*a,Q=s*L-i*c,x=s*k-r*c,E=i*k-r*L,q=l*o-h*m,T=l*R-M*m,g=l*b-y*m,S=h*R-M*o,B=h*b-y*o,D=M*b-y*R,z=f*D-V*B+p*S+Q*g-x*T+E*q;return z?(z=1/z,e[0]=(c*D-L*B+k*S)*z,e[1]=(L*g-a*D-k*T)*z,e[2]=(a*B-c*g+k*q)*z,e[3]=0,e[4]=(i*B-s*D-r*S)*z,e[5]=(n*D-i*g+r*T)*z,e[6]=(s*g-n*B-r*q)*z,e[7]=0,e[8]=(o*E-R*x+b*Q)*z,e[9]=(R*p-m*E-b*V)*z,e[10]=(m*x-o*p+b*f)*z,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e):null}static normalFromMat4Fast(e,t){let n=t[0],s=t[1],i=t[2],r=t[4],a=t[5],c=t[6],L=t[8],k=t[9],l=t[10];return e[0]=a*l-l*k,e[1]=c*L-L*l,e[2]=r*k-k*L,e[3]=0,e[4]=k*i-l*s,e[5]=l*n-L*i,e[6]=L*s-k*n,e[7]=0,e[8]=s*c-i*a,e[9]=i*r-n*c,e[10]=n*a-s*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static getTranslation(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}static getScaling(e,t){let n=t[0],s=t[1],i=t[2],r=t[4],a=t[5],c=t[6],L=t[8],k=t[9],l=t[10];return e[0]=Math.sqrt(n*n+s*s+i*i),e[1]=Math.sqrt(r*r+a*a+c*c),e[2]=Math.sqrt(L*L+k*k+l*l),e}static getRotation(e,t){d.getScaling(d.#e,t);let n=1/d.#e[0],s=1/d.#e[1],i=1/d.#e[2],r=t[0]*n,a=t[1]*s,c=t[2]*i,L=t[4]*n,k=t[5]*s,l=t[6]*i,h=t[8]*n,M=t[9]*s,y=t[10]*i,m=r+k+y,o=0;return m>0?(o=Math.sqrt(m+1)*2,e[3]=.25*o,e[0]=(l-M)/o,e[1]=(h-c)/o,e[2]=(a-L)/o):r>k&&r>y?(o=Math.sqrt(1+r-k-y)*2,e[3]=(l-M)/o,e[0]=.25*o,e[1]=(a+L)/o,e[2]=(h+c)/o):k>y?(o=Math.sqrt(1+k-r-y)*2,e[3]=(h-c)/o,e[0]=(a+L)/o,e[1]=.25*o,e[2]=(l+M)/o):(o=Math.sqrt(1+y-r-k)*2,e[3]=(a-L)/o,e[0]=(h+c)/o,e[1]=(l+M)/o,e[2]=.25*o),e}static decompose(e,t,n,s){t[0]=s[12],t[1]=s[13],t[2]=s[14];let i=s[0],r=s[1],a=s[2],c=s[4],L=s[5],k=s[6],l=s[8],h=s[9],M=s[10];n[0]=Math.sqrt(i*i+r*r+a*a),n[1]=Math.sqrt(c*c+L*L+k*k),n[2]=Math.sqrt(l*l+h*h+M*M);let y=1/n[0],m=1/n[1],o=1/n[2],R=i*y,b=r*m,f=a*o,V=c*y,p=L*m,Q=k*o,x=l*y,E=h*m,q=M*o,T=R+p+q,g=0;return T>0?(g=Math.sqrt(T+1)*2,e[3]=.25*g,e[0]=(Q-E)/g,e[1]=(x-f)/g,e[2]=(b-V)/g):R>p&&R>q?(g=Math.sqrt(1+R-p-q)*2,e[3]=(Q-E)/g,e[0]=.25*g,e[1]=(b+V)/g,e[2]=(x+f)/g):p>q?(g=Math.sqrt(1+p-R-q)*2,e[3]=(x-f)/g,e[0]=(b+V)/g,e[1]=.25*g,e[2]=(Q+E)/g):(g=Math.sqrt(1+q-R-p)*2,e[3]=(b-V)/g,e[0]=(x+f)/g,e[1]=(Q+E)/g,e[2]=.25*g),e}static fromRotationTranslationScale(e,t,n,s){let i=t[0],r=t[1],a=t[2],c=t[3],L=i+i,k=r+r,l=a+a,h=i*L,M=i*k,y=i*l,m=r*k,o=r*l,R=a*l,b=c*L,f=c*k,V=c*l,p=s[0],Q=s[1],x=s[2];return e[0]=(1-(m+R))*p,e[1]=(M+V)*p,e[2]=(y-f)*p,e[3]=0,e[4]=(M-V)*Q,e[5]=(1-(h+R))*Q,e[6]=(o+b)*Q,e[7]=0,e[8]=(y+f)*x,e[9]=(o-b)*x,e[10]=(1-(h+m))*x,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}static fromRotationTranslationScaleOrigin(e,t,n,s,i){let r=t[0],a=t[1],c=t[2],L=t[3],k=r+r,l=a+a,h=c+c,M=r*k,y=r*l,m=r*h,o=a*l,R=a*h,b=c*h,f=L*k,V=L*l,p=L*h,Q=s[0],x=s[1],E=s[2],q=i[0],T=i[1],g=i[2],S=(1-(o+b))*Q,B=(y+p)*Q,D=(m-V)*Q,z=(y-p)*x,O=(1-(M+b))*x,C=(R+f)*x,U=(m+V)*E,v=(R-f)*E,u=(1-(M+o))*E;return e[0]=S,e[1]=B,e[2]=D,e[3]=0,e[4]=z,e[5]=O,e[6]=C,e[7]=0,e[8]=U,e[9]=v,e[10]=u,e[11]=0,e[12]=n[0]+q-(S*q+z*T+U*g),e[13]=n[1]+T-(B*q+O*T+v*g),e[14]=n[2]+g-(D*q+C*T+u*g),e[15]=1,e}static fromQuat(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=n+n,c=s+s,L=i+i,k=n*a,l=s*a,h=s*c,M=i*a,y=i*c,m=i*L,o=r*a,R=r*c,b=r*L;return e[0]=1-h-m,e[1]=l+b,e[2]=M-R,e[3]=0,e[4]=l-b,e[5]=1-k-m,e[6]=y+o,e[7]=0,e[8]=M+R,e[9]=y-o,e[10]=1-k-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static frustumNO(e,t,n,s,i,r,a=1/0){let c=1/(n-t),L=1/(i-s);if(e[0]=r*2*c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r*2*L,e[6]=0,e[7]=0,e[8]=(n+t)*c,e[9]=(i+s)*L,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,a!=null&&a!==1/0){let k=1/(r-a);e[10]=(a+r)*k,e[14]=2*a*r*k}else e[10]=-1,e[14]=-2*r;return e}static frustum(e,t,n,s,i,r,a=1/0){return e}static frustumZO(e,t,n,s,i,r,a=1/0){let c=1/(n-t),L=1/(i-s);if(e[0]=r*2*c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r*2*L,e[6]=0,e[7]=0,e[8]=(n+t)*c,e[9]=(i+s)*L,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,a!=null&&a!==1/0){let k=1/(r-a);e[10]=a*k,e[14]=a*r*k}else e[10]=-1,e[14]=-r;return e}static perspectiveNO(e,t,n,s,i=1/0){let r=1/Math.tan(t/2);if(e[0]=r/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0){let a=1/(s-i);e[10]=(i+s)*a,e[14]=2*i*s*a}else e[10]=-1,e[14]=-2*s;return e}static perspective(e,t,n,s,i=1/0){return e}static perspectiveZO(e,t,n,s,i=1/0){let r=1/Math.tan(t/2);if(e[0]=r/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0){let a=1/(s-i);e[10]=i*a,e[14]=i*s*a}else e[10]=-1,e[14]=-s;return e}static perspectiveFromFieldOfView(e,t,n,s){let i=Math.tan(t.upDegrees*Math.PI/180),r=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),c=Math.tan(t.rightDegrees*Math.PI/180),L=2/(a+c),k=2/(i+r);return e[0]=L,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=k,e[6]=0,e[7]=0,e[8]=-((a-c)*L*.5),e[9]=(i-r)*k*.5,e[10]=s/(n-s),e[11]=-1,e[12]=0,e[13]=0,e[14]=s*n/(n-s),e[15]=0,e}static orthoNO(e,t,n,s,i,r,a){let c=1/(t-n),L=1/(s-i),k=1/(r-a);return e[0]=-2*c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*L,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*k,e[11]=0,e[12]=(t+n)*c,e[13]=(i+s)*L,e[14]=(a+r)*k,e[15]=1,e}static ortho(e,t,n,s,i,r,a){return e}static orthoZO(e,t,n,s,i,r,a){let c=1/(t-n),L=1/(s-i),k=1/(r-a);return e[0]=-2*c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*L,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=k,e[11]=0,e[12]=(t+n)*c,e[13]=(i+s)*L,e[14]=r*k,e[15]=1,e}static lookAt(e,t,n,s){let i=t[0],r=t[1],a=t[2],c=s[0],L=s[1],k=s[2],l=n[0],h=n[1],M=n[2];if(Math.abs(i-l)<I&&Math.abs(r-h)<I&&Math.abs(a-M)<I)return d.identity(e);let y=i-l,m=r-h,o=a-M,R=1/Math.sqrt(y*y+m*m+o*o);y*=R,m*=R,o*=R;let b=L*o-k*m,f=k*y-c*o,V=c*m-L*y;R=Math.sqrt(b*b+f*f+V*V),R?(R=1/R,b*=R,f*=R,V*=R):(b=0,f=0,V=0);let p=m*V-o*f,Q=o*b-y*V,x=y*f-m*b;return R=Math.sqrt(p*p+Q*Q+x*x),R?(R=1/R,p*=R,Q*=R,x*=R):(p=0,Q=0,x=0),e[0]=b,e[1]=p,e[2]=y,e[3]=0,e[4]=f,e[5]=Q,e[6]=m,e[7]=0,e[8]=V,e[9]=x,e[10]=o,e[11]=0,e[12]=-(b*i+f*r+V*a),e[13]=-(p*i+Q*r+x*a),e[14]=-(y*i+m*r+o*a),e[15]=1,e}static targetTo(e,t,n,s){let i=t[0],r=t[1],a=t[2],c=s[0],L=s[1],k=s[2],l=i-n[0],h=r-n[1],M=a-n[2],y=l*l+h*h+M*M;y>0&&(y=1/Math.sqrt(y),l*=y,h*=y,M*=y);let m=L*M-k*h,o=k*l-c*M,R=c*h-L*l;return y=m*m+o*o+R*R,y>0&&(y=1/Math.sqrt(y),m*=y,o*=y,R*=y),e[0]=m,e[1]=o,e[2]=R,e[3]=0,e[4]=h*R-M*o,e[5]=M*m-l*R,e[6]=l*o-h*m,e[7]=0,e[8]=l,e[9]=h,e[10]=M,e[11]=0,e[12]=i,e[13]=r,e[14]=a,e[15]=1,e}static frob(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]+e[4]*e[4]+e[5]*e[5]+e[6]*e[6]+e[7]*e[7]+e[8]*e[8]+e[9]*e[9]+e[10]*e[10]+e[11]*e[11]+e[12]*e[12]+e[13]*e[13]+e[14]*e[14]+e[15]*e[15])}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}static sub(e,t,n){return e}static multiplyScalar(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}static multiplyScalarAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e[3]=t[3]+n[3]*s,e[4]=t[4]+n[4]*s,e[5]=t[5]+n[5]*s,e[6]=t[6]+n[6]*s,e[7]=t[7]+n[7]*s,e[8]=t[8]+n[8]*s,e[9]=t[9]+n[9]*s,e[10]=t[10]+n[10]*s,e[11]=t[11]+n[11]*s,e[12]=t[12]+n[12]*s,e[13]=t[13]+n[13]*s,e[14]=t[14]+n[14]*s,e[15]=t[15]+n[15]*s,e}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=e[4],c=e[5],L=e[6],k=e[7],l=e[8],h=e[9],M=e[10],y=e[11],m=e[12],o=e[13],R=e[14],b=e[15],f=t[0],V=t[1],p=t[2],Q=t[3],x=t[4],E=t[5],q=t[6],T=t[7],g=t[8],S=t[9],B=t[10],D=t[11],z=t[12],O=t[13],C=t[14],U=t[15];return Math.abs(n-f)<=I*Math.max(1,Math.abs(n),Math.abs(f))&&Math.abs(s-V)<=I*Math.max(1,Math.abs(s),Math.abs(V))&&Math.abs(i-p)<=I*Math.max(1,Math.abs(i),Math.abs(p))&&Math.abs(r-Q)<=I*Math.max(1,Math.abs(r),Math.abs(Q))&&Math.abs(a-x)<=I*Math.max(1,Math.abs(a),Math.abs(x))&&Math.abs(c-E)<=I*Math.max(1,Math.abs(c),Math.abs(E))&&Math.abs(L-q)<=I*Math.max(1,Math.abs(L),Math.abs(q))&&Math.abs(k-T)<=I*Math.max(1,Math.abs(k),Math.abs(T))&&Math.abs(l-g)<=I*Math.max(1,Math.abs(l),Math.abs(g))&&Math.abs(h-S)<=I*Math.max(1,Math.abs(h),Math.abs(S))&&Math.abs(M-B)<=I*Math.max(1,Math.abs(M),Math.abs(B))&&Math.abs(y-D)<=I*Math.max(1,Math.abs(y),Math.abs(D))&&Math.abs(m-z)<=I*Math.max(1,Math.abs(m),Math.abs(z))&&Math.abs(o-O)<=I*Math.max(1,Math.abs(o),Math.abs(O))&&Math.abs(R-C)<=I*Math.max(1,Math.abs(R),Math.abs(C))&&Math.abs(b-U)<=I*Math.max(1,Math.abs(b),Math.abs(U))}static str(e){return`Mat4(${e.join(", ")})`}};Y.prototype.mul=Y.prototype.multiply;Y.sub=Y.subtract;Y.mul=Y.multiply;Y.frustum=Y.frustumNO;Y.perspective=Y.perspectiveNO;Y.ortho=Y.orthoNO;import{GLM_EPSILON as K}from"gl-matrix/common";var A=class d extends Float32Array{constructor(...e){switch(e.length){case 3:super(e);break;case 2:super(e[0],e[1],3);break;case 1:{let t=e[0];typeof t=="number"?super([t,t,t]):super(t,0,3);break}default:super(3);break}}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}get r(){return this[0]}set r(e){this[0]=e}get g(){return this[1]}set g(e){this[1]=e}get b(){return this[2]}set b(e){this[2]=e}get magnitude(){let e=this[0],t=this[1],n=this[2];return Math.sqrt(e*e+t*t+n*n)}get mag(){return this.magnitude}get squaredMagnitude(){let e=this[0],t=this[1],n=this[2];return e*e+t*t+n*n}get sqrMag(){return this.squaredMagnitude}get str(){return d.str(this)}copy(e){return this.set(e),this}add(e){return this[0]+=e[0],this[1]+=e[1],this[2]+=e[2],this}subtract(e){return this[0]-=e[0],this[1]-=e[1],this[2]-=e[2],this}sub(e){return this}multiply(e){return this[0]*=e[0],this[1]*=e[1],this[2]*=e[2],this}mul(e){return this}divide(e){return this[0]/=e[0],this[1]/=e[1],this[2]/=e[2],this}div(e){return this}scale(e){return this[0]*=e,this[1]*=e,this[2]*=e,this}scaleAndAdd(e,t){return this[0]+=e[0]*t,this[1]+=e[1]*t,this[2]+=e[2]*t,this}distance(e){return d.distance(this,e)}dist(e){return 0}squaredDistance(e){return d.squaredDistance(this,e)}sqrDist(e){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this[2]=Math.abs(this[2]),this}dot(e){return this[0]*e[0]+this[1]*e[1]+this[2]*e[2]}normalize(){return d.normalize(this,this)}static get BYTE_LENGTH(){return 3*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static magnitude(e){let t=e[0],n=e[1],s=e[2];return Math.sqrt(t*t+n*n+s*s)}static mag(e){return 0}static length(e){return 0}static len(e){return 0}static fromValues(e,t,n){return new d(e,t,n)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}static set(e,t,n,s){return e[0]=t,e[1]=n,e[2]=s,e}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}static sub(e,t,n){return[0,0,0]}static multiply(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}static mul(e,t,n){return[0,0,0]}static divide(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e}static div(e,t,n){return[0,0,0]}static ceil(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e}static floor(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e}static min(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e}static max(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e}static scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}static scaleAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e}static distance(e,t){let n=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+s*s+i*i)}static dist(e,t){return 0}static squaredDistance(e,t){let n=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2];return n*n+s*s+i*i}static sqrDist(e,t){return 0}static squaredLength(e){let t=e[0],n=e[1],s=e[2];return t*t+n*n+s*s}static sqrLen(e,t){return 0}static negate(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}static inverse(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}static abs(e,t){return e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e}static normalize(e,t){let n=t[0],s=t[1],i=t[2],r=n*n+s*s+i*i;return r>0&&(r=1/Math.sqrt(r)),e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}static dot(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}static cross(e,t,n){let s=t[0],i=t[1],r=t[2],a=n[0],c=n[1],L=n[2];return e[0]=i*L-r*c,e[1]=r*a-s*L,e[2]=s*c-i*a,e}static lerp(e,t,n,s){let i=t[0],r=t[1],a=t[2];return e[0]=i+s*(n[0]-i),e[1]=r+s*(n[1]-r),e[2]=a+s*(n[2]-a),e}static slerp(e,t,n,s){let i=Math.acos(Math.min(Math.max(d.dot(t,n),-1),1)),r=Math.sin(i),a=Math.sin((1-s)*i)/r,c=Math.sin(s*i)/r;return e[0]=a*t[0]+c*n[0],e[1]=a*t[1]+c*n[1],e[2]=a*t[2]+c*n[2],e}static hermite(e,t,n,s,i,r){let a=r*r,c=a*(2*r-3)+1,L=a*(r-2)+r,k=a*(r-1),l=a*(3-2*r);return e[0]=t[0]*c+n[0]*L+s[0]*k+i[0]*l,e[1]=t[1]*c+n[1]*L+s[1]*k+i[1]*l,e[2]=t[2]*c+n[2]*L+s[2]*k+i[2]*l,e}static bezier(e,t,n,s,i,r){let a=1-r,c=a*a,L=r*r,k=c*a,l=3*r*c,h=3*L*a,M=L*r;return e[0]=t[0]*k+n[0]*l+s[0]*h+i[0]*M,e[1]=t[1]*k+n[1]*l+s[1]*h+i[1]*M,e[2]=t[2]*k+n[2]*l+s[2]*h+i[2]*M,e}static transformMat4(e,t,n){let s=t[0],i=t[1],r=t[2],a=n[3]*s+n[7]*i+n[11]*r+n[15]||1;return e[0]=(n[0]*s+n[4]*i+n[8]*r+n[12])/a,e[1]=(n[1]*s+n[5]*i+n[9]*r+n[13])/a,e[2]=(n[2]*s+n[6]*i+n[10]*r+n[14])/a,e}static transformMat3(e,t,n){let s=t[0],i=t[1],r=t[2];return e[0]=s*n[0]+i*n[3]+r*n[6],e[1]=s*n[1]+i*n[4]+r*n[7],e[2]=s*n[2]+i*n[5]+r*n[8],e}static transformQuat(e,t,n){let s=n[0],i=n[1],r=n[2],a=n[3]*2,c=t[0],L=t[1],k=t[2],l=i*k-r*L,h=r*c-s*k,M=s*L-i*c,y=(i*M-r*h)*2,m=(r*l-s*M)*2,o=(s*h-i*l)*2;return e[0]=c+l*a+y,e[1]=L+h*a+m,e[2]=k+M*a+o,e}static rotateX(e,t,n,s){let i=n[1],r=n[2],a=t[1]-i,c=t[2]-r;return e[0]=t[0],e[1]=a*Math.cos(s)-c*Math.sin(s)+i,e[2]=a*Math.sin(s)+c*Math.cos(s)+r,e}static rotateY(e,t,n,s){let i=n[0],r=n[2],a=t[0]-i,c=t[2]-r;return e[0]=c*Math.sin(s)+a*Math.cos(s)+i,e[1]=t[1],e[2]=c*Math.cos(s)-a*Math.sin(s)+r,e}static rotateZ(e,t,n,s){let i=n[0],r=n[1],a=t[0]-i,c=t[1]-r;return e[0]=a*Math.cos(s)-c*Math.sin(s)+i,e[1]=a*Math.sin(s)+c*Math.cos(s)+r,e[2]=n[2],e}static angle(e,t){let n=e[0],s=e[1],i=e[2],r=t[0],a=t[1],c=t[2],L=Math.sqrt((n*n+s*s+i*i)*(r*r+a*a+c*c)),k=L&&d.dot(e,t)/L;return Math.acos(Math.min(Math.max(k,-1),1))}static zero(e){return e[0]=0,e[1]=0,e[2]=0,e}static str(e){return`Vec3(${e.join(", ")})`}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=t[0],a=t[1],c=t[2];return Math.abs(n-r)<=K*Math.max(1,Math.abs(n),Math.abs(r))&&Math.abs(s-a)<=K*Math.max(1,Math.abs(s),Math.abs(a))&&Math.abs(i-c)<=K*Math.max(1,Math.abs(i),Math.abs(c))}};A.prototype.sub=A.prototype.subtract;A.prototype.mul=A.prototype.multiply;A.prototype.div=A.prototype.divide;A.prototype.dist=A.prototype.distance;A.prototype.sqrDist=A.prototype.squaredDistance;A.sub=A.subtract;A.mul=A.multiply;A.div=A.divide;A.dist=A.distance;A.sqrDist=A.squaredDistance;A.sqrLen=A.squaredLength;A.mag=A.magnitude;A.length=A.magnitude;A.len=A.magnitude;import{GLM_EPSILON as J}from"gl-matrix/common";var w=class d extends Float32Array{constructor(...e){switch(e.length){case 4:super(e);break;case 2:super(e[0],e[1],4);break;case 1:{let t=e[0];typeof t=="number"?super([t,t,t,t]):super(t,0,4);break}default:super(4);break}}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}get w(){return this[3]}set w(e){this[3]=e}get r(){return this[0]}set r(e){this[0]=e}get g(){return this[1]}set g(e){this[1]=e}get b(){return this[2]}set b(e){this[2]=e}get a(){return this[3]}set a(e){this[3]=e}get magnitude(){let e=this[0],t=this[1],n=this[2],s=this[3];return Math.sqrt(e*e+t*t+n*n+s*s)}get mag(){return this.magnitude}get str(){return d.str(this)}copy(e){return super.set(e),this}add(e){return this[0]+=e[0],this[1]+=e[1],this[2]+=e[2],this[3]+=e[3],this}subtract(e){return this[0]-=e[0],this[1]-=e[1],this[2]-=e[2],this[3]-=e[3],this}sub(e){return this}multiply(e){return this[0]*=e[0],this[1]*=e[1],this[2]*=e[2],this[3]*=e[3],this}mul(e){return this}divide(e){return this[0]/=e[0],this[1]/=e[1],this[2]/=e[2],this[3]/=e[3],this}div(e){return this}scale(e){return this[0]*=e,this[1]*=e,this[2]*=e,this[3]*=e,this}scaleAndAdd(e,t){return this[0]+=e[0]*t,this[1]+=e[1]*t,this[2]+=e[2]*t,this[3]+=e[3]*t,this}distance(e){return d.distance(this,e)}dist(e){return 0}squaredDistance(e){return d.squaredDistance(this,e)}sqrDist(e){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this[3]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this[3]=1/this[3],this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this[2]=Math.abs(this[2]),this[3]=Math.abs(this[3]),this}dot(e){return this[0]*e[0]+this[1]*e[1]+this[2]*e[2]+this[3]*e[3]}normalize(){return d.normalize(this,this)}static get BYTE_LENGTH(){return 4*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static fromValues(e,t,n,s){return new d(e,t,n,s)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static set(e,t,n,s,i){return e[0]=t,e[1]=n,e[2]=s,e[3]=i,e}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e}static sub(e,t,n){return e}static multiply(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e}static mul(e,t,n){return e}static divide(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e}static div(e,t,n){return e}static ceil(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e}static floor(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e}static min(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e}static max(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e}static round(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e}static scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e}static scaleAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e[2]=t[2]+n[2]*s,e[3]=t[3]+n[3]*s,e}static distance(e,t){let n=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2],r=t[3]-e[3];return Math.hypot(n,s,i,r)}static dist(e,t){return 0}static squaredDistance(e,t){let n=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2],r=t[3]-e[3];return n*n+s*s+i*i+r*r}static sqrDist(e,t){return 0}static magnitude(e){let t=e[0],n=e[1],s=e[2],i=e[3];return Math.sqrt(t*t+n*n+s*s+i*i)}static mag(e){return 0}static length(e){return 0}static len(e){return 0}static squaredLength(e){let t=e[0],n=e[1],s=e[2],i=e[3];return t*t+n*n+s*s+i*i}static sqrLen(e){return 0}static negate(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}static inverse(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e}static abs(e,t){return e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e[3]=Math.abs(t[3]),e}static normalize(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=n*n+s*s+i*i+r*r;return a>0&&(a=1/Math.sqrt(a)),e[0]=n*a,e[1]=s*a,e[2]=i*a,e[3]=r*a,e}static dot(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}static cross(e,t,n,s){let i=n[0]*s[1]-n[1]*s[0],r=n[0]*s[2]-n[2]*s[0],a=n[0]*s[3]-n[3]*s[0],c=n[1]*s[2]-n[2]*s[1],L=n[1]*s[3]-n[3]*s[1],k=n[2]*s[3]-n[3]*s[2],l=t[0],h=t[1],M=t[2],y=t[3];return e[0]=h*k-M*L+y*c,e[1]=-(l*k)+M*a-y*r,e[2]=l*L-h*a+y*i,e[3]=-(l*c)+h*r-M*i,e}static lerp(e,t,n,s){let i=t[0],r=t[1],a=t[2],c=t[3];return e[0]=i+s*(n[0]-i),e[1]=r+s*(n[1]-r),e[2]=a+s*(n[2]-a),e[3]=c+s*(n[3]-c),e}static transformMat4(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3];return e[0]=n[0]*s+n[4]*i+n[8]*r+n[12]*a,e[1]=n[1]*s+n[5]*i+n[9]*r+n[13]*a,e[2]=n[2]*s+n[6]*i+n[10]*r+n[14]*a,e[3]=n[3]*s+n[7]*i+n[11]*r+n[15]*a,e}static transformQuat(e,t,n){let s=t[0],i=t[1],r=t[2],a=n[0],c=n[1],L=n[2],k=n[3],l=k*s+c*r-L*i,h=k*i+L*s-a*r,M=k*r+a*i-c*s,y=-a*s-c*i-L*r;return e[0]=l*k+y*-a+h*-L-M*-c,e[1]=h*k+y*-c+M*-a-l*-L,e[2]=M*k+y*-L+l*-c-h*-a,e[3]=t[3],e}static zero(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}static str(e){return`Vec4(${e.join(", ")})`}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=t[0],c=t[1],L=t[2],k=t[3];return Math.abs(n-a)<=J*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(s-c)<=J*Math.max(1,Math.abs(s),Math.abs(c))&&Math.abs(i-L)<=J*Math.max(1,Math.abs(i),Math.abs(L))&&Math.abs(r-k)<=J*Math.max(1,Math.abs(r),Math.abs(k))}};w.prototype.sub=w.prototype.subtract;w.prototype.mul=w.prototype.multiply;w.prototype.div=w.prototype.divide;w.prototype.dist=w.prototype.distance;w.prototype.sqrDist=w.prototype.squaredDistance;w.sub=w.subtract;w.mul=w.multiply;w.div=w.divide;w.dist=w.distance;w.sqrDist=w.squaredDistance;w.sqrLen=w.squaredLength;w.mag=w.magnitude;w.length=w.magnitude;w.len=w.magnitude;import{GLM_EPSILON as _}from"gl-matrix/common";var N=class d extends Float32Array{static#t="zyx";static#e=new Float32Array(4);static#i=new Float32Array(4);static#n=new Float32Array(9);static#s=new Float32Array(3);static#r=new Float32Array([1,0,0]);static#a=new Float32Array([0,1,0]);constructor(...e){switch(e.length){case 4:super(e);break;case 2:super(e[0],e[1],4);break;case 1:{let t=e[0];typeof t=="number"?super([t,t,t,t]):super(t,0,4);break}default:super(4),this[3]=1;break}}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}get w(){return this[3]}set w(e){this[3]=e}get magnitude(){let e=this[0],t=this[1],n=this[2],s=this[3];return Math.sqrt(e*e+t*t+n*n+s*s)}get mag(){return this.magnitude}get str(){return d.str(this)}copy(e){return super.set(e),this}identity(){return this[0]=0,this[1]=0,this[2]=0,this[3]=1,this}multiply(e){return d.multiply(this,this,e)}mul(e){return this}rotateX(e){return d.rotateX(this,this,e)}rotateY(e){return d.rotateY(this,this,e)}rotateZ(e){return d.rotateZ(this,this,e)}invert(){return d.invert(this,this)}scale(e){return this[0]*=e,this[1]*=e,this[2]*=e,this[3]*=e,this}dot(e){return d.dot(this,e)}static get BYTE_LENGTH(){return 4*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static identity(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}static setAxisAngle(e,t,n){n*=.5;let s=Math.sin(n);return e[0]=s*t[0],e[1]=s*t[1],e[2]=s*t[2],e[3]=Math.cos(n),e}static getAxisAngle(e,t){let n=Math.acos(t[3])*2,s=Math.sin(n/2);return s>_?(e[0]=t[0]/s,e[1]=t[1]/s,e[2]=t[2]/s):(e[0]=1,e[1]=0,e[2]=0),n}static getAngle(e,t){let n=d.dot(e,t);return Math.acos(2*n*n-1)}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[0],L=n[1],k=n[2],l=n[3];return e[0]=s*l+a*c+i*k-r*L,e[1]=i*l+a*L+r*c-s*k,e[2]=r*l+a*k+s*L-i*c,e[3]=a*l-s*c-i*L-r*k,e}static rotateX(e,t,n){n*=.5;let s=t[0],i=t[1],r=t[2],a=t[3],c=Math.sin(n),L=Math.cos(n);return e[0]=s*L+a*c,e[1]=i*L+r*c,e[2]=r*L-i*c,e[3]=a*L-s*c,e}static rotateY(e,t,n){n*=.5;let s=t[0],i=t[1],r=t[2],a=t[3],c=Math.sin(n),L=Math.cos(n);return e[0]=s*L-r*c,e[1]=i*L+a*c,e[2]=r*L+s*c,e[3]=a*L-i*c,e}static rotateZ(e,t,n){n*=.5;let s=t[0],i=t[1],r=t[2],a=t[3],c=Math.sin(n),L=Math.cos(n);return e[0]=s*L+i*c,e[1]=i*L-s*c,e[2]=r*L+a*c,e[3]=a*L-r*c,e}static calculateW(e,t){let n=t[0],s=t[1],i=t[2];return e[0]=n,e[1]=s,e[2]=i,e[3]=Math.sqrt(Math.abs(1-n*n-s*s-i*i)),e}static exp(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=Math.sqrt(n*n+s*s+i*i),c=Math.exp(r),L=a>0?c*Math.sin(a)/a:0;return e[0]=n*L,e[1]=s*L,e[2]=i*L,e[3]=c*Math.cos(a),e}static ln(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=Math.sqrt(n*n+s*s+i*i),c=a>0?Math.atan2(a,r)/a:0;return e[0]=n*c,e[1]=s*c,e[2]=i*c,e[3]=.5*Math.log(n*n+s*s+i*i+r*r),e}static pow(e,t,n){return d.ln(e,t),d.scale(e,e,n),d.exp(e,e),e}static slerp(e,t,n,s){let i=t[0],r=t[1],a=t[2],c=t[3],L=n[0],k=n[1],l=n[2],h=n[3],M,y,m=i*L+r*k+a*l+c*h;if(m<0&&(m=-m,L=-L,k=-k,l=-l,h=-h),1-m>_){let o=Math.acos(m),R=Math.sin(o);M=Math.sin((1-s)*o)/R,y=Math.sin(s*o)/R}else M=1-s,y=s;return e[0]=M*i+y*L,e[1]=M*r+y*k,e[2]=M*a+y*l,e[3]=M*c+y*h,e}static invert(e,t){let n=t[0],s=t[1],i=t[2],r=t[3],a=n*n+s*s+i*i+r*r,c=a?1/a:0;return e[0]=-n*c,e[1]=-s*c,e[2]=-i*c,e[3]=r*c,e}static conjugate(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e}static fromMat3(e,t){let n=t[0]+t[4]+t[8],s;if(n>0)s=Math.sqrt(n+1),e[3]=.5*s,s=.5/s,e[0]=(t[5]-t[7])*s,e[1]=(t[6]-t[2])*s,e[2]=(t[1]-t[3])*s;else{let i=0;t[4]>t[0]&&(i=1),t[8]>t[i*3+i]&&(i=2);let r=(i+1)%3,a=(i+2)%3;s=Math.sqrt(t[i*3+i]-t[r*3+r]-t[a*3+a]+1),e[i]=.5*s,s=.5/s,e[3]=(t[r*3+a]-t[a*3+r])*s,e[r]=(t[r*3+i]+t[i*3+r])*s,e[a]=(t[a*3+i]+t[i*3+a])*s}return e}static fromEuler(e,t,n,s,i=d.#t){let r=.5*Math.PI/180;t*=r,n*=r,s*=r;let a=Math.sin(t),c=Math.cos(t),L=Math.sin(n),k=Math.cos(n),l=Math.sin(s),h=Math.cos(s);switch(i){case"xyz":e[0]=a*k*h+c*L*l,e[1]=c*L*h-a*k*l,e[2]=c*k*l+a*L*h,e[3]=c*k*h-a*L*l;break;case"xzy":e[0]=a*k*h-c*L*l,e[1]=c*L*h-a*k*l,e[2]=c*k*l+a*L*h,e[3]=c*k*h+a*L*l;break;case"yxz":e[0]=a*k*h+c*L*l,e[1]=c*L*h-a*k*l,e[2]=c*k*l-a*L*h,e[3]=c*k*h+a*L*l;break;case"yzx":e[0]=a*k*h+c*L*l,e[1]=c*L*h+a*k*l,e[2]=c*k*l-a*L*h,e[3]=c*k*h-a*L*l;break;case"zxy":e[0]=a*k*h-c*L*l,e[1]=c*L*h+a*k*l,e[2]=c*k*l+a*L*h,e[3]=c*k*h-a*L*l;break;case"zyx":e[0]=a*k*h-c*L*l,e[1]=c*L*h+a*k*l,e[2]=c*k*l-a*L*h,e[3]=c*k*h+a*L*l;break;default:throw new Error(`Unknown angle order ${i}`)}return e}static str(e){return`Quat(${e.join(", ")})`}static clone(e){return new d(e)}static fromValues(e,t,n,s){return new d(e,t,n,s)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static set(e,t,n,s,i){return e}static add(e,t,n){return e}static mul(e,t,n){return e}static scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e}static dot(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}static lerp(e,t,n,s){return e}static magnitude(e){return 0}static mag(e){return 0}static length(e){return 0}static len(e){return 0}static squaredLength(e){return 0}static sqrLen(e){return 0}static normalize(e,t){return e}static exactEquals(e,t){return!1}static equals(e,t){return!1}static rotationTo(e,t,n){let s=A.dot(t,n);return s<-.999999?(A.cross(d.#s,d.#r,t),A.mag(d.#s)<1e-6&&A.cross(d.#s,d.#a,t),A.normalize(d.#s,d.#s),d.setAxisAngle(e,d.#s,Math.PI),e):s>.999999?(e[0]=0,e[1]=0,e[2]=0,e[3]=1,e):(A.cross(d.#s,t,n),e[0]=d.#s[0],e[1]=d.#s[1],e[2]=d.#s[2],e[3]=1+s,d.normalize(e,e))}static sqlerp(e,t,n,s,i,r){return d.slerp(d.#e,t,i,r),d.slerp(d.#i,n,s,r),d.slerp(e,d.#e,d.#i,2*r*(1-r)),e}static setAxes(e,t,n,s){return d.#n[0]=n[0],d.#n[3]=n[1],d.#n[6]=n[2],d.#n[1]=s[0],d.#n[4]=s[1],d.#n[7]=s[2],d.#n[2]=-t[0],d.#n[5]=-t[1],d.#n[8]=-t[2],d.normalize(e,d.fromMat3(e,d.#n))}};N.set=w.set;N.add=w.add;N.lerp=w.lerp;N.normalize=w.normalize;N.squaredLength=w.squaredLength;N.sqrLen=w.squaredLength;N.exactEquals=w.exactEquals;N.equals=w.equals;N.magnitude=w.magnitude;N.prototype.mul=N.prototype.multiply;N.mul=N.multiply;N.mag=N.magnitude;N.length=N.magnitude;N.len=N.magnitude;import{GLM_EPSILON as X}from"gl-matrix/common";var P=class d extends Float32Array{static#t=new Float32Array(4);static#e=new Float32Array(3);constructor(...e){switch(e.length){case 8:super(e);break;case 2:super(e[0],e[1],8);break;case 1:{let t=e[0];typeof t=="number"?super([t,t,t,t,t,t,t,t]):super(t,0,8);break}default:super(8),this[3]=1;break}}get str(){return d.str(this)}copy(e){return super.set(e),this}static get BYTE_LENGTH(){return 8*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static fromValues(e,t,n,s,i,r,a,c){return new d(e,t,n,s,i,r,a,c)}static fromRotationTranslationValues(e,t,n,s,i,r,a){let c=i*.5,L=r*.5,k=a*.5;return new d(e,t,n,s,c*s+L*n-k*t,L*s+k*e-c*n,k*s+c*t-L*e,-c*e-L*t-k*n)}static fromRotationTranslation(e,t,n){let s=n[0]*.5,i=n[1]*.5,r=n[2]*.5,a=t[0],c=t[1],L=t[2],k=t[3];return e[0]=a,e[1]=c,e[2]=L,e[3]=k,e[4]=s*k+i*L-r*c,e[5]=i*k+r*a-s*L,e[6]=r*k+s*c-i*a,e[7]=-s*a-i*c-r*L,e}static fromTranslation(e,t){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=t[0]*.5,e[5]=t[1]*.5,e[6]=t[2]*.5,e[7]=0,e}static fromRotation(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}static fromMat4(e,t){return Y.getRotation(d.#t,t),Y.getTranslation(d.#e,t),d.fromRotationTranslation(e,d.#t,d.#e)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e}static identity(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}static set(e,t,n,s,i,r,a,c,L){return e[0]=t,e[1]=n,e[2]=s,e[3]=i,e[4]=r,e[5]=a,e[6]=c,e[7]=L,e}static getReal(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static getDual(e,t){return e[0]=t[4],e[1]=t[5],e[2]=t[6],e[3]=t[7],e}static setReal(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}static setDual(e,t){return e[4]=t[0],e[5]=t[1],e[6]=t[2],e[7]=t[3],e}static getTranslation(e,t){let n=t[4],s=t[5],i=t[6],r=t[7],a=-t[0],c=-t[1],L=-t[2],k=t[3];return e[0]=(n*k+r*a+s*L-i*c)*2,e[1]=(s*k+r*c+i*a-n*L)*2,e[2]=(i*k+r*L+n*c-s*a)*2,e}static translate(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[0]*.5,L=n[1]*.5,k=n[2]*.5,l=t[4],h=t[5],M=t[6],y=t[7];return e[0]=s,e[1]=i,e[2]=r,e[3]=a,e[4]=a*c+i*k-r*L+l,e[5]=a*L+r*c-s*k+h,e[6]=a*k+s*L-i*c+M,e[7]=-s*c-i*L-r*k+y,e}static rotateX(e,t,n){let s=-t[0],i=-t[1],r=-t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=c*a+l*s+L*r-k*i,M=L*a+l*i+k*s-c*r,y=k*a+l*r+c*i-L*s,m=l*a-c*s-L*i-k*r;return N.rotateX(e,t,n),s=e[0],i=e[1],r=e[2],a=e[3],e[4]=h*a+m*s+M*r-y*i,e[5]=M*a+m*i+y*s-h*r,e[6]=y*a+m*r+h*i-M*s,e[7]=m*a-h*s-M*i-y*r,e}static rotateY(e,t,n){let s=-t[0],i=-t[1],r=-t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=c*a+l*s+L*r-k*i,M=L*a+l*i+k*s-c*r,y=k*a+l*r+c*i-L*s,m=l*a-c*s-L*i-k*r;return N.rotateY(e,t,n),s=e[0],i=e[1],r=e[2],a=e[3],e[4]=h*a+m*s+M*r-y*i,e[5]=M*a+m*i+y*s-h*r,e[6]=y*a+m*r+h*i-M*s,e[7]=m*a-h*s-M*i-y*r,e}static rotateZ(e,t,n){let s=-t[0],i=-t[1],r=-t[2],a=t[3],c=t[4],L=t[5],k=t[6],l=t[7],h=c*a+l*s+L*r-k*i,M=L*a+l*i+k*s-c*r,y=k*a+l*r+c*i-L*s,m=l*a-c*s-L*i-k*r;return N.rotateZ(e,t,n),s=e[0],i=e[1],r=e[2],a=e[3],e[4]=h*a+m*s+M*r-y*i,e[5]=M*a+m*i+y*s-h*r,e[6]=y*a+m*r+h*i-M*s,e[7]=m*a-h*s-M*i-y*r,e}static rotateByQuatAppend(e,t,n){let s=n[0],i=n[1],r=n[2],a=n[3],c=t[0],L=t[1],k=t[2],l=t[3];return e[0]=c*a+l*s+L*r-k*i,e[1]=L*a+l*i+k*s-c*r,e[2]=k*a+l*r+c*i-L*s,e[3]=l*a-c*s-L*i-k*r,c=t[4],L=t[5],k=t[6],l=t[7],e[4]=c*a+l*s+L*r-k*i,e[5]=L*a+l*i+k*s-c*r,e[6]=k*a+l*r+c*i-L*s,e[7]=l*a-c*s-L*i-k*r,e}static rotateByQuatPrepend(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[0],L=n[1],k=n[2],l=n[3];return e[0]=s*l+a*c+i*k-r*L,e[1]=i*l+a*L+r*c-s*k,e[2]=r*l+a*k+s*L-i*c,e[3]=a*l-s*c-i*L-r*k,c=n[4],L=n[5],k=n[6],l=n[7],e[4]=s*l+a*c+i*k-r*L,e[5]=i*l+a*L+r*c-s*k,e[6]=r*l+a*k+s*L-i*c,e[7]=a*l-s*c-i*L-r*k,e}static rotateAroundAxis(e,t,n,s){if(Math.abs(s)<X)return d.copy(e,t);let i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);s*=.5;let r=Math.sin(s),a=r*n[0]/i,c=r*n[1]/i,L=r*n[2]/i,k=Math.cos(s),l=t[0],h=t[1],M=t[2],y=t[3];e[0]=l*k+y*a+h*L-M*c,e[1]=h*k+y*c+M*a-l*L,e[2]=M*k+y*L+l*c-h*a,e[3]=y*k-l*a-h*c-M*L;let m=t[4],o=t[5],R=t[6],b=t[7];return e[4]=m*k+b*a+o*L-R*c,e[5]=o*k+b*c+R*a-m*L,e[6]=R*k+b*L+m*c-o*a,e[7]=b*k-m*a-o*c-R*L,e}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e}static multiply(e,t,n){let s=t[0],i=t[1],r=t[2],a=t[3],c=n[4],L=n[5],k=n[6],l=n[7],h=t[4],M=t[5],y=t[6],m=t[7],o=n[0],R=n[1],b=n[2],f=n[3];return e[0]=s*f+a*o+i*b-r*R,e[1]=i*f+a*R+r*o-s*b,e[2]=r*f+a*b+s*R-i*o,e[3]=a*f-s*o-i*R-r*b,e[4]=s*l+a*c+i*k-r*L+h*f+m*o+M*b-y*R,e[5]=i*l+a*L+r*c-s*k+M*f+m*R+y*o-h*b,e[6]=r*l+a*k+s*L-i*c+y*f+m*b+h*R-M*o,e[7]=a*l-s*c-i*L-r*k+m*f-h*o-M*R-y*b,e}static mul(e,t,n){return e}static scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e}static dot(e,t){return 0}static lerp(e,t,n,s){let i=1-s;return d.dot(t,n)<0&&(s=-s),e[0]=t[0]*i+n[0]*s,e[1]=t[1]*i+n[1]*s,e[2]=t[2]*i+n[2]*s,e[3]=t[3]*i+n[3]*s,e[4]=t[4]*i+n[4]*s,e[5]=t[5]*i+n[5]*s,e[6]=t[6]*i+n[6]*s,e[7]=t[7]*i+n[7]*s,e}static invert(e,t){let n=d.squaredLength(t);return e[0]=-t[0]/n,e[1]=-t[1]/n,e[2]=-t[2]/n,e[3]=t[3]/n,e[4]=-t[4]/n,e[5]=-t[5]/n,e[6]=-t[6]/n,e[7]=t[7]/n,e}static conjugate(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=t[7],e}static magnitude(e){return 0}static mag(e){return 0}static length(e){return 0}static len(e){return 0}static squaredLength(e){return 0}static sqrLen(e){return 0}static normalize(e,t){let n=d.squaredLength(t);if(n>0){n=Math.sqrt(n);let s=t[0]/n,i=t[1]/n,r=t[2]/n,a=t[3]/n,c=t[4],L=t[5],k=t[6],l=t[7],h=s*c+i*L+r*k+a*l;e[0]=s,e[1]=i,e[2]=r,e[3]=a,e[4]=(c-s*h)/n,e[5]=(L-i*h)/n,e[6]=(k-r*h)/n,e[7]=(l-a*h)/n}return e}static str(e){return`Quat2(${e.join(", ")})`}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]}static equals(e,t){let n=e[0],s=e[1],i=e[2],r=e[3],a=e[4],c=e[5],L=e[6],k=e[7],l=t[0],h=t[1],M=t[2],y=t[3],m=t[4],o=t[5],R=t[6],b=t[7];return Math.abs(n-l)<=X*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(s-h)<=X*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(i-M)<=X*Math.max(1,Math.abs(i),Math.abs(M))&&Math.abs(r-y)<=X*Math.max(1,Math.abs(r),Math.abs(y))&&Math.abs(a-m)<=X*Math.max(1,Math.abs(a),Math.abs(m))&&Math.abs(c-o)<=X*Math.max(1,Math.abs(c),Math.abs(o))&&Math.abs(L-R)<=X*Math.max(1,Math.abs(L),Math.abs(R))&&Math.abs(k-b)<=X*Math.max(1,Math.abs(k),Math.abs(b))}};P.dot=N.dot;P.squaredLength=N.squaredLength;P.sqrLen=N.squaredLength;P.mag=N.magnitude;P.length=N.magnitude;P.len=N.magnitude;P.mul=P.multiply;import{GLM_EPSILON as ee}from"gl-matrix/common";var F=class d extends Float32Array{constructor(...e){switch(e.length){case 2:{let t=e[0];typeof t=="number"?super([t,e[1]]):super(t,e[1],2);break}case 1:{let t=e[0];typeof t=="number"?super([t,t]):super(t,0,2);break}default:super(2);break}}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get r(){return this[0]}set r(e){this[0]=e}get g(){return this[1]}set g(e){this[1]=e}get magnitude(){return Math.hypot(this[0],this[1])}get mag(){return this.magnitude}get squaredMagnitude(){let e=this[0],t=this[1];return e*e+t*t}get sqrMag(){return this.squaredMagnitude}get str(){return d.str(this)}copy(e){return this.set(e),this}add(e){return this[0]+=e[0],this[1]+=e[1],this}subtract(e){return this[0]-=e[0],this[1]-=e[1],this}sub(e){return this}multiply(e){return this[0]*=e[0],this[1]*=e[1],this}mul(e){return this}divide(e){return this[0]/=e[0],this[1]/=e[1],this}div(e){return this}scale(e){return this[0]*=e,this[1]*=e,this}scaleAndAdd(e,t){return this[0]+=e[0]*t,this[1]+=e[1]*t,this}distance(e){return d.distance(this,e)}dist(e){return 0}squaredDistance(e){return d.squaredDistance(this,e)}sqrDist(e){return 0}negate(){return this[0]*=-1,this[1]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this}dot(e){return this[0]*e[0]+this[1]*e[1]}normalize(){return d.normalize(this,this)}static get BYTE_LENGTH(){return 2*Float32Array.BYTES_PER_ELEMENT}static create(){return new d}static clone(e){return new d(e)}static fromValues(e,t){return new d(e,t)}static copy(e,t){return e[0]=t[0],e[1]=t[1],e}static set(e,t,n){return e[0]=t,e[1]=n,e}static add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e}static subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e}static sub(e,t,n){return[0,0]}static multiply(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e}static mul(e,t,n){return[0,0]}static divide(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e}static div(e,t,n){return[0,0]}static ceil(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e}static floor(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e}static min(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e}static max(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e}static round(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e}static scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e}static scaleAndAdd(e,t,n,s){return e[0]=t[0]+n[0]*s,e[1]=t[1]+n[1]*s,e}static distance(e,t){return Math.hypot(t[0]-e[0],t[1]-e[1])}static dist(e,t){return 0}static squaredDistance(e,t){let n=t[0]-e[0],s=t[1]-e[1];return n*n+s*s}static sqrDist(e,t){return 0}static magnitude(e){let t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}static mag(e){return 0}static length(e){return 0}static len(e){return 0}static squaredLength(e){let t=e[0],n=e[1];return t*t+n*n}static sqrLen(e,t){return 0}static negate(e,t){return e[0]=-t[0],e[1]=-t[1],e}static inverse(e,t){return e[0]=1/t[0],e[1]=1/t[1],e}static abs(e,t){return e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e}static normalize(e,t){let n=t[0],s=t[1],i=n*n+s*s;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e}static dot(e,t){return e[0]*t[0]+e[1]*t[1]}static cross(e,t,n){let s=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=s,e}static lerp(e,t,n,s){let i=t[0],r=t[1];return e[0]=i+s*(n[0]-i),e[1]=r+s*(n[1]-r),e}static transformMat2(e,t,n){let s=t[0],i=t[1];return e[0]=n[0]*s+n[2]*i,e[1]=n[1]*s+n[3]*i,e}static transformMat2d(e,t,n){let s=t[0],i=t[1];return e[0]=n[0]*s+n[2]*i+n[4],e[1]=n[1]*s+n[3]*i+n[5],e}static transformMat3(e,t,n){let s=t[0],i=t[1];return e[0]=n[0]*s+n[3]*i+n[6],e[1]=n[1]*s+n[4]*i+n[7],e}static transformMat4(e,t,n){let s=t[0],i=t[1];return e[0]=n[0]*s+n[4]*i+n[12],e[1]=n[1]*s+n[5]*i+n[13],e}static rotate(e,t,n,s){let i=t[0]-n[0],r=t[1]-n[1],a=Math.sin(s),c=Math.cos(s);return e[0]=i*c-r*a+n[0],e[1]=i*a+r*c+n[1],e}static angle(e,t){let n=e[0],s=e[1],i=t[0],r=t[1],a=Math.sqrt(n*n+s*s)*Math.sqrt(i*i+r*r),c=a&&(n*i+s*r)/a;return Math.acos(Math.min(Math.max(c,-1),1))}static zero(e){return e[0]=0,e[1]=0,e}static exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]}static equals(e,t){let n=e[0],s=e[1],i=t[0],r=t[1];return Math.abs(n-i)<=ee*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(s-r)<=ee*Math.max(1,Math.abs(s),Math.abs(r))}static str(e){return`Vec2(${e.join(", ")})`}};F.prototype.sub=F.prototype.subtract;F.prototype.mul=F.prototype.multiply;F.prototype.div=F.prototype.divide;F.prototype.dist=F.prototype.distance;F.prototype.sqrDist=F.prototype.squaredDistance;F.sub=F.subtract;F.mul=F.multiply;F.div=F.divide;F.dist=F.distance;F.sqrDist=F.squaredDistance;F.sqrLen=F.squaredLength;F.mag=F.magnitude;F.length=F.magnitude;F.len=F.magnitude;export{G as Mat2,$ as Mat2d,Z as Mat3,Y as Mat4,N as Quat,P as Quat2,F as Vec2,A as Vec3,w as Vec4};
//# sourceMappingURL=index.min.js.map
